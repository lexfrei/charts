# Default values for cloudflare-tunnel.

# -- Cloudflare parameters
cloudflare:
  # -- Your Cloudflare account number
  account: ""
  # -- The name of the tunnel this instance will serve
  tunnelName: ""
  # -- The ID of the above tunnel
  tunnelId: ""
  # -- The secret for the tunnel
  secret: ""
  # -- If defined, no secret is created for the credentials, and instead, the secret referenced is used
  secretName: null
  # -- If true, turn on WARP routing for TCP
  enableWarp: false
  # -- Define ingress rules for the tunnel
  # See <https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/configuration-file/ingress>
  ingress:
    []
    # The first rule proxies traffic to the httpbin sample service named web-server at port 80
    # - hostname: tunnel.example.com
    #  service: http://web-service:80
    # This rule sends traffic to the built-in hello-world HTTP server. This can help debug connectivity
    # issues. If hello.example.com resolves and tunnel.example.com does not, then the problem is
    # in the connection from cloudflared to your local service, not from the internet to cloudflared.
    # - hostname: hello.example.com
    #   service: hello_world
  # -- If true, enable the default 404 page. Needs to be false if you want to use a '*' wildcard rule.
  enableDefault404: true
  # -- Global originRequest configuration for all ingress rules
  # See <https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/configuration-file/ingress#origin-request>
  originRequest: {}
    # connectTimeout: 30s
    # tlsTimeout: 10s
    # keepAliveTimeout: 90s
    # noHappyEyeballs: false
    # keepAliveConnections: 100
    # httpHostHeader: ""
    # originServerName: ""
    # caPool: ""
    # noTLSVerify: false
    # disableChunkedEncoding: false
    # bastionMode: false
    # proxyAddress: ""
    # proxyPort: 0
    # proxyType: ""
    # ipRules: []
    # http2Origin: false

# -- The image to use
image:
  repository: cloudflare/cloudflared
  pullPolicy: IfNotPresent
  # -- If supplied, this overrides "appVersion"
  tag: ""

# -- The version of the image to use
replicaCount: 2

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

# -- Security items common to everything in the pod.  Here we require that it does not run as the user defined in the image, literally named "nonroot"
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65532

# -- Security items for one container. We lock it down
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true

resources:
  {}
  # -- We usually recommend not to specify default resources and to leave this as a conscious
  # -- choice for the user. This also increases chances charts run on environments with little
  # -- resources, such as Minikube. If you do want to specify resources, uncomment the following
  # -- lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

nodeSelector: {}

tolerations: []

# -- Default affinity is to spread out over nodes; use this to override
affinity: {}

serviceMonitor:
  # -- Enable prometheus Service Monitor
  enabled: false
  # -- Job label for the ServiceMonitor
  jobLabel: ""
  # -- Scrape interval for Prometheus
  interval: ""
  # -- Metric relabelings for the ServiceMonitor
  metricRelabelings: []
  # -- Relabelings for the ServiceMonitor
  relabelings: []

# -- Pod Disruption Budget configuration
podDisruptionBudget:
  # -- Enable Pod Disruption Budget
  enabled: false
  # -- Minimum number of available pods (conflicts with maxUnavailable)
  minAvailable: 1
  # -- Maximum number of unavailable pods (conflicts with minAvailable)
  # maxUnavailable: 1

# -- Topology spread constraints for pod distribution across zones/nodes
# See <https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/>
topologySpreadConstraints: []
  # - maxSkew: 1
  #   topologyKey: topology.kubernetes.io/zone
  #   whenUnsatisfiable: DoNotSchedule
  #   labelSelector:
  #     matchLabels:
  #       app.kubernetes.io/name: cloudflare-tunnel

# -- Priority class name for pod scheduling priority
# See <https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/>
priorityClassName: ""

# -- Metrics port for Prometheus metrics and readiness probe
metricsPort: 2000

# -- Liveness probe configuration
livenessProbe:
  # -- Failure threshold for liveness probe
  failureThreshold: 1
  # -- Initial delay before liveness probe starts
  initialDelaySeconds: 30
  # -- Period between liveness probe checks
  periodSeconds: 10
  # -- Timeout for liveness probe
  # timeoutSeconds: 1

# -- Log level for cloudflared (debug, info, warn, error, fatal)
logLevel: ""

# -- Additional labels to add to pods
podLabels: {}

# -- Deployment mode: "deployment" or "daemonset"
# DaemonSet mode ensures one tunnel pod per node, useful for:
# - Preventing port exhaustion from multiple pods on same node
# - Following Cloudflare's recommendation to limit instances per node
# - Ensuring predictable distribution and node-level reliability
deploymentMode: deployment

# -- Transport protocol for cloudflared (auto, quic, http2)
# auto: Cloudflare selects the best protocol automatically
# quic: Force QUIC transport (fastest, most reliable)
# http2: Force HTTP/2 transport (wider compatibility)
# Leave empty to use cloudflared default
protocol: ""

# -- Enable post-quantum cryptography for QUIC connections
# Only works with 'quic' or 'auto' protocol, conflicts with 'http2'
# See: <https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/cloudflared-parameters/run-parameters/#post-quantum>
postQuantum: false

# -- Cloudflare region (us for US-only, empty for global)
# When set to "us", cloudflared will only connect to US Cloudflare edge servers
# Leave empty for global edge selection
region: ""

# -- Maximum retries for connection/protocol errors
# Number of retries cloudflared will attempt for network errors
# Leave empty to use cloudflared default (5)
retries: ""

# -- IP version for edge connections (auto, 4, 6)
# auto: Cloudflare selects optimal IP version automatically
# 4: Force IPv4 connections to Cloudflare edge
# 6: Force IPv6 connections to Cloudflare edge
# Leave empty to use cloudflared default
edgeIpVersion: ""

# -- Graceful shutdown timeout (e.g., 30s, 1m)
# Time to wait for connections to close gracefully during shutdown
# Format: number followed by time unit (s for seconds, m for minutes)
# Leave empty to use cloudflared default
gracePeriod: ""

# -- Edge bind address for outgoing connections
# Specify the outgoing IP address for tunnel connections to Cloudflare edge
# Useful for multi-homed servers with multiple network interfaces
# Leave empty to use system default
edgeBindAddress: ""

# -- Tags for tunnel identification and monitoring
# Key-value pairs for tagging tunnel instances in Cloudflare dashboard
# Useful for grouping, monitoring, and analytics
# Example: {"environment": "production", "team": "backend"}
tags: {}
